{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nimport { useAppDispatch, useAppSelector } from 'store/hooks/hooks';\nimport { fetchCarEngineMode, fetchCarDrive } from 'CONSTANTS/Axios';\nimport { deleteCar, setSelectedCar } from 'store/modules/garageListReducer';\nimport { newWinner, updateWinner } from 'store/modules/winnersListReducer';\nimport styles from './GarageTableRow.module.scss';\nconst getAnimationStyle = (raceStatus, time) => ({\n  animationName: styles.moveToEnd,\n  animationDuration: `${time}s`,\n  animationTimingFunction: 'linear',\n  animationDelay: '4.2s',\n  animationFillMode: 'forwards',\n  animationPlayState: raceStatus === 'brokenEngine' ? 'paused' : 'running'\n});\nconst startCar = (id, selectedCar, dispatch, setRaceStatus, setTime) => {\n  setRaceStatus('stopped');\n  setTimeout(() => {\n    setRaceStatus('started');\n    if ((selectedCar === null || selectedCar === void 0 ? void 0 : selectedCar.id) === id) dispatch(setSelectedCar(undefined));\n    fetchCarEngineMode(id, 'started').then(response => {\n      if (!(response !== null && response !== void 0 && response.isFailed)) {\n        const raceTime = response.distance / (response.velocity * 500);\n        setTimeout(() => {\n          fetchCarDrive(id).then(res => {\n            if (res !== null && res !== void 0 && res.isFailed && res.status === 500) {\n              setRaceStatus('brokenEngine');\n            }\n          });\n        }, 4200);\n        setTime(raceTime);\n      } else setRaceStatus('stopped');\n    });\n  }, 0);\n};\nconst stopCar = (id, setRaceStatus) => {\n  fetchCarEngineMode(id, 'stopped');\n  setRaceStatus('stopped');\n};\nfunction UseGarageTableRow(carData) {\n  _s();\n  const dispatch = useAppDispatch();\n  const {\n    id\n  } = carData;\n  const {\n    selectedCar,\n    race,\n    winner\n  } = useAppSelector(store => store.garageList);\n  const {\n    winnersList\n  } = useAppSelector(store => store.winnersList);\n  const [time, setTime] = useState(0);\n  const [raceStatus, setRaceStatus] = useState('stopped');\n  const animationStyle = getAnimationStyle(raceStatus, time);\n  const handleStart = () => startCar(id, selectedCar, dispatch, setRaceStatus, setTime);\n  const handleStop = () => stopCar(id, setRaceStatus);\n  const handleFinish = () => {\n    if (race && !winner) {\n      const lastWin = winnersList.find(winner => winner.id === id);\n      const timeNewValue = Number((time * 5).toFixed(3));\n      if (lastWin) dispatch(updateWinner({\n        ...lastWin,\n        wins: lastWin.wins + 1,\n        time: Math.min(lastWin.time, timeNewValue)\n      }));else dispatch(newWinner({\n        ...carData,\n        time: timeNewValue\n      }));\n    }\n    setRaceStatus('finished');\n  };\n  const toggleSelect = () => dispatch(setSelectedCar((selectedCar === null || selectedCar === void 0 ? void 0 : selectedCar.id) == id ? undefined : carData));\n  const handleDelete = () => dispatch(deleteCar(id));\n  useEffect(() => {\n    if (race && race != 'finished' && race !== raceStatus) race === 'started' ? handleStart() : handleStop();\n  }, [race]);\n  return {\n    handleStart,\n    handleStop,\n    toggleSelect,\n    handleDelete,\n    raceStatus,\n    animationStyle,\n    handleFinish\n  };\n}\n_s(UseGarageTableRow, \"WCTA5yd8JJp5e6QVfgPZ64ltZyY=\", false, function () {\n  return [useAppDispatch, useAppSelector, useAppSelector];\n});\n_c = UseGarageTableRow;\nexport default UseGarageTableRow;\nvar _c;\n$RefreshReg$(_c, \"UseGarageTableRow\");","map":{"version":3,"names":["useState","useEffect","useAppDispatch","useAppSelector","fetchCarEngineMode","fetchCarDrive","deleteCar","setSelectedCar","newWinner","updateWinner","styles","getAnimationStyle","raceStatus","time","animationName","moveToEnd","animationDuration","animationTimingFunction","animationDelay","animationFillMode","animationPlayState","startCar","id","selectedCar","dispatch","setRaceStatus","setTime","setTimeout","undefined","then","response","isFailed","raceTime","distance","velocity","res","status","stopCar","UseGarageTableRow","carData","_s","race","winner","store","garageList","winnersList","animationStyle","handleStart","handleStop","handleFinish","lastWin","find","timeNewValue","Number","toFixed","wins","Math","min","toggleSelect","handleDelete","_c","$RefreshReg$"],"sources":["C:/Users/Admin/Documents/GitHub/Async-Race/src/components/commons/GarageTableRow/UseGarageTableRow.ts"],"sourcesContent":["import React, { FC, useState, useEffect, CSSProperties } from 'react';\nimport { useAppDispatch, useAppSelector } from 'store/hooks/hooks';\n\nimport { fetchCarEngineMode, fetchCarDrive } from 'CONSTANTS/Axios';\nimport { deleteCar, setSelectedCar } from 'store/modules/garageListReducer';\nimport { newWinner, updateWinner, Winner } from 'store/modules/winnersListReducer';\nimport { AppDispatch } from 'store/configureReduxStore';\n\nimport styles from './GarageTableRow.module.scss';\n\ninterface CarData {\n   id: number;\n   name: string;\n   color: string;\n}\n\ntype RaceStatus = 'stopped' | 'started' | 'finished' | 'brokenEngine';\n\ninterface UseGarageTableRowReturn {\n   handleStart: () => void;\n   handleStop: () => void;\n   toggleSelect: () => void;\n   handleDelete: () => void;\n   raceStatus: RaceStatus;\n   animationStyle: CSSProperties;\n   handleFinish: () => void;\n}\n\nconst getAnimationStyle = (raceStatus: string, time: number): CSSProperties => ({\n   animationName: styles.moveToEnd,\n   animationDuration: `${time}s`,\n   animationTimingFunction: 'linear',\n   animationDelay: '4.2s',\n   animationFillMode: 'forwards',\n   animationPlayState: raceStatus === 'brokenEngine' ? 'paused' : 'running',\n});\n\nconst startCar = (\n   id: number,\n   selectedCar: CarData | undefined,\n   dispatch: AppDispatch,\n   setRaceStatus: React.Dispatch<React.SetStateAction<RaceStatus>>,\n   setTime: React.Dispatch<React.SetStateAction<number>>\n) => {\n   setRaceStatus('stopped');\n   setTimeout(() => {\n      setRaceStatus('started');\n      if (selectedCar?.id === id) dispatch(setSelectedCar(undefined));\n\n      fetchCarEngineMode(id, 'started').then((response) => {\n         if (!response?.isFailed) {\n            const raceTime = response.distance / (response.velocity * 500);\n            setTimeout(() => {\n               fetchCarDrive(id).then((res) => {\n                  if (res?.isFailed && res.status === 500) {\n                     setRaceStatus('brokenEngine');\n                  }\n               });\n            }, 4200);\n            setTime(raceTime);\n         } else setRaceStatus('stopped');\n      });\n   }, 0);\n};\n\nconst stopCar = (id: number, setRaceStatus: React.Dispatch<React.SetStateAction<RaceStatus>>) => {\n   fetchCarEngineMode(id, 'stopped');\n   setRaceStatus('stopped');\n};\n\nfunction UseGarageTableRow(carData: CarData): UseGarageTableRowReturn {\n   const dispatch = useAppDispatch();\n   const { id } = carData;\n   const { selectedCar, race, winner } = useAppSelector((store) => store.garageList);\n   const { winnersList } = useAppSelector((store) => store.winnersList)\n   const [time, setTime] = useState<number>(0);\n   const [raceStatus, setRaceStatus] = useState<RaceStatus>('stopped');\n   const animationStyle: CSSProperties = getAnimationStyle(raceStatus, time);\n\n   const handleStart = () => startCar(id, selectedCar, dispatch, setRaceStatus, setTime);\n   const handleStop = () => stopCar(id, setRaceStatus);\n   const handleFinish = () => {\n      if (race && !winner) {\n         const lastWin = winnersList.find((winner: Winner) => winner.id === id);\n         const timeNewValue = Number((time * 5).toFixed(3));\n         if (lastWin)\n            dispatch(\n               updateWinner({\n                  ...lastWin,\n                  wins: lastWin.wins + 1,\n                  time: Math.min(lastWin.time, timeNewValue),\n               })\n            );\n         else dispatch(newWinner({ ...carData, time: timeNewValue }));\n      }\n      setRaceStatus('finished');\n   };\n   const toggleSelect = () => dispatch(setSelectedCar(selectedCar?.id == id ? undefined : carData));\n   const handleDelete = () => dispatch(deleteCar(id));\n   useEffect(() => {\n      if (race && race != 'finished' && race !== raceStatus) race === 'started' ? handleStart() : handleStop();\n   }, [race]);\n\n   return { handleStart, handleStop, toggleSelect, handleDelete, raceStatus, animationStyle, handleFinish };\n}\n\nexport default UseGarageTableRow;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}