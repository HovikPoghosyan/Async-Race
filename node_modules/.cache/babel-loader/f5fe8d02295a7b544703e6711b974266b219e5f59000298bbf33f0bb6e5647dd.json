{"ast":null,"code":"// /* eslint-disable */\n// /* prettier-ignore */\n// import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n\n// import { getRandomCarName, getRandomColor } from 'CONSTANTS/CarData';\n\n// import {\n//    fetchGarageList,\n//    fetchWinnersList,\n//    fetchNewCar,\n//    fetchDeleteCar,\n//    fetchUpdateCar,\n//    fetchNewWinner,\n//    fetchUpdateWinner,\n//    fetchDeleteWinner,\n// } from 'CONSTANTS/Axios';\n\n// import type { RootState } from 'store/configureReduxStore';\n\n// export interface Car {\n//    id: number;\n//    name: string;\n//    color: string;\n// }\n\n// export interface CarData {\n//    name: string;\n//    color: string;\n// }\n\n// export interface Winner {\n//    id: number;\n//    wins: number;\n//    time: number;\n//    name: string;\n//    color: string;\n// }\n\n// interface ListState {\n//    garageList: Car[];\n//    winnersList: Winner[];\n//    selectedCar?: Car;\n//    loading: boolean;\n//    race?: string;\n//    winner?: Partial<Winner>;\n//    winnerPopup: boolean;\n//    winnersSortBy?: string;\n//    winnersSortDirection?: string;\n// }\n\n// const generateCars = createAsyncThunk<void, number, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/generateCars',\n//    async (count, { dispatch }) => {\n//       for (let index = 0; index < count; index++) {\n//          dispatch(\n//             addNewCar({\n//                name: getRandomCarName(),\n//                color: getRandomColor(),\n//             })\n//          );\n//       }\n//    }\n// );\n\n// const addNewCar = createAsyncThunk<CarData, CarData, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/addNewCar',\n//    async (carData, { rejectWithValue }) => {\n//       const data = await fetchNewCar(carData);\n//       if (data.isFailed) return rejectWithValue({ isFailed: true });\n\n//       return data;\n//    }\n// );\n\n// const newWinner = createAsyncThunk<Winner, Partial<Winner>, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/newWinner',\n//    async (carData, { rejectWithValue }) => {\n//       const data = await fetchNewWinner(carData);\n//       if (data.isFailed) return rejectWithValue({ isFailed: true });\n\n//       return data;\n//    }\n// );\n\n// const updateWinner = createAsyncThunk<Winner, Winner, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/updateWinner',\n//    async (carData, { rejectWithValue }) => {\n//       const data = await fetchUpdateWinner(carData);\n//       if (data.isFailed) return rejectWithValue({ isFailed: true });\n\n//       return data;\n//    }\n// );\n\n// const updateCar = createAsyncThunk<Car, Car, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/updateCar',\n//    async (carData, { rejectWithValue, dispatch, getState }) => {\n//       const data = await fetchUpdateCar(carData);\n//       const { winnersList } = getState().list;\n//       const carInWinnersList = winnersList.find((w) => w.id === carData.id);\n//       if (data?.isFailed) return rejectWithValue({ isFailed: true });\n//       if (!!carInWinnersList) dispatch(updateWinner(carInWinnersList)).unwrap();\n\n//       return data;\n//    }\n// );\n\n// const deleteCar = createAsyncThunk<number, number, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/deleteCar',\n//    async (id, { rejectWithValue, getState }) => {\n//       const data = await fetchDeleteCar(id);\n//       const { winnersList } = getState().list;\n//       const carIsWinner = winnersList.some((winner) => winner.id === id);\n//       if (carIsWinner) fetchDeleteWinner(id);\n//       if (data.isFailed) return rejectWithValue({ isFailed: true });\n\n//       return data;\n//    }\n// );\n\n// const getGarageLists = createAsyncThunk<Car[], void, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/getGarageLists',\n//    async (props, { rejectWithValue }) => {\n//       const data = await fetchGarageList();\n//       if (data.isFailed) return rejectWithValue({ isFailed: true });\n\n//       return data;\n//    }\n// );\n\n// const getWinnersLists = createAsyncThunk<Winner[], void, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/getWinnersLists',\n//    async (props, { rejectWithValue }) => {\n//       const data = await fetchWinnersList();\n//       if (data.isFailed) return rejectWithValue({ isFailed: true });\n\n//       return data;\n//    }\n// );\n\n// const initialState: ListState = {\n//    garageList: [],\n//    winnersList: [],\n//    selectedCar: undefined,\n//    loading: false,\n//    race: undefined,\n//    winner: undefined,\n//    winnerPopup: false,\n//    winnersSortBy: undefined,\n//    winnersSortDirection: undefined,\n// };\n\n// const appSlice = createSlice({\n//    name: 'list',\n//    initialState,\n//    reducers: {\n//       setSelectedCar(state, { payload }) {\n//          state.selectedCar = payload;\n//       },\n//       setRace(state, { payload }) {\n//          if (payload != 'finished') state.winner = undefined;\n//          state.race = payload;\n//       },\n//       closeWinnerPopup(state) {\n//          state.winnerPopup = false;\n//       },\n//       setWinnersList(state, { payload }) {\n//          state.winnersList = payload;\n//       },\n//    },\n//    extraReducers: (builder) => {\n//       builder\n//          .addCase(deleteCar.pending, (state, { meta }) => {\n//             const selectedId = state.selectedCar?.id;\n//             const deletingId = meta.arg;\n//             if (selectedId !== undefined && selectedId === deletingId) {\n//                state.selectedCar = undefined;\n//             }\n//          })\n//          .addCase(deleteCar.fulfilled, (state, { meta }) => {\n//             state.garageList = state.garageList.filter((car) => car.id !== meta.arg);\n//             state.winnersList = state.winnersList.filter((car) => car.id !== meta.arg);\n//          })\n//          .addCase(newWinner.pending, (state, { meta }) => {\n//             state.race = 'finished';\n//             state.winner = meta.arg;\n//             state.winnerPopup = true;\n//          })\n//          .addCase(newWinner.fulfilled, (state, { meta }) => {\n//             state.winnersList = [\n//                ...state.winnersList,\n//                {\n//                   name: meta.arg.name || 'name',\n//                   color: meta.arg.color || '#ccc',\n//                   id: meta.arg.id || 3,\n//                   time: meta.arg.time || 33,\n//                   wins: 1,\n//                },\n//             ];\n//          })\n//          .addCase(updateWinner.pending, (state) => {\n//             state.race = 'finished';\n//          })\n//          .addCase(updateWinner.fulfilled, (state, { meta }) => {\n//             state.winnersList = state.winnersList.map((winner) =>\n//                winner.id === meta.arg.id\n//                   ? {\n//                        ...winner,\n//                        wins: meta.arg.wins,\n//                        time: meta.arg.time,\n//                     }\n//                   : winner\n//             );\n//          })\n//          .addCase(addNewCar.fulfilled, (state, { meta }) => {\n//             state.garageList = [\n//                ...state.garageList,\n//                {\n//                   name: meta.arg.name,\n//                   color: meta.arg.color,\n//                   id: state.garageList.length ? state.garageList[state.garageList.length - 1].id + 1 : 1,\n//                },\n//             ];\n//          })\n//          .addCase(updateCar.fulfilled, (state, { meta }) => {\n//             state.garageList = state.garageList.map((car) =>\n//                car.id === meta.arg.id\n//                   ? {\n//                        color: meta.arg.color,\n//                        name: meta.arg.name,\n//                        id: meta.arg.id,\n//                     }\n//                   : car\n//             );\n//          })\n//          .addCase(getGarageLists.pending, (state) => {\n//             state.loading = true;\n//          })\n//          .addCase(getGarageLists.fulfilled, (state, { payload }) => {\n//             state.garageList = payload;\n//             state.loading = false;\n//          })\n//          .addCase(getGarageLists.rejected, (state, { payload }) => {\n//             state.loading = false;\n//          })\n//          .addCase(getWinnersLists.fulfilled, (state, { payload }) => {\n//             const restyleList: Winner[] = payload\n//                .map((winner: Partial<Winner>) => {\n//                   const car = state.garageList.find((current) => current.id === winner.id);\n//                   if (car?.name && car?.color && winner?.id && winner?.time && winner?.wins)\n//                      return {\n//                         ...winner,\n//                         name: car.name,\n//                         color: car.color,\n//                      };\n//                })\n//                .filter((winner): winner is Winner => winner !== undefined);\n//             state.winnersList = restyleList;\n//             state.loading = false;\n//          })\n//          .addCase(getWinnersLists.rejected, (state) => {\n//             state.loading = false;\n//          });\n//    },\n// });\n\n// export const { setRace, setSelectedCar, closeWinnerPopup, setWinnersList } = appSlice.actions;\n// export { getGarageLists, getWinnersLists, generateCars, addNewCar, updateCar, deleteCar, newWinner, updateWinner };\n// export default appSlice.reducer;\n\n/* eslint-disable */\n/* prettier-ignore */\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { fetchWinnersList, fetchNewWinner, fetchUpdateWinner, fetchDeleteWinner } from 'CONSTANTS/Axios';\nimport { openWinnerPopup, setRace } from './garageListReducer';\nconst initialState = {\n  winnersList: [],\n  winner: undefined,\n  loading: false\n};\nconst newWinner = createAsyncThunk('winnersList/newWinner', async (carData, {\n  rejectWithValue,\n  dispatch\n}) => {\n  const data = await fetchNewWinner(carData);\n  if (data.isFailed) return rejectWithValue({\n    isFailed: true\n  });\n  dispatch(setRace('finished'));\n  dispatch(openWinnerPopup());\n  return data;\n});\nconst updateWinner = createAsyncThunk('winnersList/updateWinner', async (carData, {\n  rejectWithValue\n}) => {\n  console.log('carData new winner: ', carData);\n  const data = await fetchUpdateWinner(carData);\n  if (data.isFailed) return rejectWithValue({\n    isFailed: true\n  });\n  return data;\n});\nconst deleteWinner = createAsyncThunk('winnersList/deleteWinner', async (id, {\n  rejectWithValue\n}) => {\n  const data = await fetchDeleteWinner(id);\n  if (data.isFailed) return rejectWithValue({\n    isFailed: true\n  });\n  return data;\n});\nconst getWinnersLists = createAsyncThunk('winnersList/getWinnersLists', async (props, {\n  rejectWithValue,\n  getState\n}) => {\n  const data = await fetchWinnersList();\n  if (data.isFailed) return rejectWithValue({\n    isFailed: true\n  });\n  const {\n    garageList\n  } = getState().garageList;\n  return data.map(winner => {\n    const car = garageList.find(car => car.id === winner.id);\n    return {\n      ...winner,\n      name: (car === null || car === void 0 ? void 0 : car.name) || 'unknown',\n      color: (car === null || car === void 0 ? void 0 : car.color) || '#ccc'\n    };\n  });\n});\nconst winnersListReducer = createSlice({\n  name: 'winnersList',\n  initialState,\n  reducers: {\n    setWinnersList(state, {\n      payload\n    }) {\n      state.winnersList = payload;\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(newWinner.pending, (state, {\n      meta\n    }) => {\n      state.winner = meta.arg;\n    }).addCase(newWinner.fulfilled, (state, {\n      meta\n    }) => {\n      state.winnersList.push({\n        id: meta.arg.id,\n        time: meta.arg.time,\n        wins: 1,\n        name: meta.arg.name || 'car',\n        color: meta.arg.color || '#ccc'\n      });\n    }).addCase(updateWinner.fulfilled, (state, {\n      meta\n    }) => {\n      state.winnersList = state.winnersList.map(winner => winner.id === meta.arg.id ? {\n        ...winner,\n        wins: meta.arg.wins,\n        time: meta.arg.time\n      } : winner);\n    }).addCase(deleteWinner.fulfilled, (state, {\n      payload\n    }) => {\n      state.winnersList = state.winnersList.filter(winner => winner.id !== payload);\n    }).addCase(getWinnersLists.pending, state => {\n      state.loading = true;\n    }).addCase(getWinnersLists.fulfilled, (state, {\n      payload\n    }) => {\n      state.winnersList = payload;\n      state.loading = false;\n    }).addCase(getWinnersLists.rejected, state => {\n      state.loading = false;\n    });\n  }\n});\nexport const {\n  setWinnersList\n} = winnersListReducer.actions;\nexport { updateWinner, getWinnersLists, deleteWinner, newWinner };\nexport default winnersListReducer.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","fetchWinnersList","fetchNewWinner","fetchUpdateWinner","fetchDeleteWinner","openWinnerPopup","setRace","initialState","winnersList","winner","undefined","loading","newWinner","carData","rejectWithValue","dispatch","data","isFailed","updateWinner","console","log","deleteWinner","id","getWinnersLists","props","getState","garageList","map","car","find","name","color","winnersListReducer","reducers","setWinnersList","state","payload","extraReducers","builder","addCase","pending","meta","arg","fulfilled","push","time","wins","filter","rejected","actions","reducer"],"sources":["C:/Users/Admin/Documents/GitHub/Async-Race/src/store/modules/winnersListReducer.ts"],"sourcesContent":["// /* eslint-disable */\n// /* prettier-ignore */\n// import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n\n// import { getRandomCarName, getRandomColor } from 'CONSTANTS/CarData';\n\n// import {\n//    fetchGarageList,\n//    fetchWinnersList,\n//    fetchNewCar,\n//    fetchDeleteCar,\n//    fetchUpdateCar,\n//    fetchNewWinner,\n//    fetchUpdateWinner,\n//    fetchDeleteWinner,\n// } from 'CONSTANTS/Axios';\n\n// import type { RootState } from 'store/configureReduxStore';\n\n// export interface Car {\n//    id: number;\n//    name: string;\n//    color: string;\n// }\n\n// export interface CarData {\n//    name: string;\n//    color: string;\n// }\n\n// export interface Winner {\n//    id: number;\n//    wins: number;\n//    time: number;\n//    name: string;\n//    color: string;\n// }\n\n// interface ListState {\n//    garageList: Car[];\n//    winnersList: Winner[];\n//    selectedCar?: Car;\n//    loading: boolean;\n//    race?: string;\n//    winner?: Partial<Winner>;\n//    winnerPopup: boolean;\n//    winnersSortBy?: string;\n//    winnersSortDirection?: string;\n// }\n\n// const generateCars = createAsyncThunk<void, number, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/generateCars',\n//    async (count, { dispatch }) => {\n//       for (let index = 0; index < count; index++) {\n//          dispatch(\n//             addNewCar({\n//                name: getRandomCarName(),\n//                color: getRandomColor(),\n//             })\n//          );\n//       }\n//    }\n// );\n\n// const addNewCar = createAsyncThunk<CarData, CarData, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/addNewCar',\n//    async (carData, { rejectWithValue }) => {\n//       const data = await fetchNewCar(carData);\n//       if (data.isFailed) return rejectWithValue({ isFailed: true });\n\n//       return data;\n//    }\n// );\n\n// const newWinner = createAsyncThunk<Winner, Partial<Winner>, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/newWinner',\n//    async (carData, { rejectWithValue }) => {\n//       const data = await fetchNewWinner(carData);\n//       if (data.isFailed) return rejectWithValue({ isFailed: true });\n\n//       return data;\n//    }\n// );\n\n// const updateWinner = createAsyncThunk<Winner, Winner, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/updateWinner',\n//    async (carData, { rejectWithValue }) => {\n//       const data = await fetchUpdateWinner(carData);\n//       if (data.isFailed) return rejectWithValue({ isFailed: true });\n\n//       return data;\n//    }\n// );\n\n// const updateCar = createAsyncThunk<Car, Car, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/updateCar',\n//    async (carData, { rejectWithValue, dispatch, getState }) => {\n//       const data = await fetchUpdateCar(carData);\n//       const { winnersList } = getState().list;\n//       const carInWinnersList = winnersList.find((w) => w.id === carData.id);\n//       if (data?.isFailed) return rejectWithValue({ isFailed: true });\n//       if (!!carInWinnersList) dispatch(updateWinner(carInWinnersList)).unwrap();\n\n//       return data;\n//    }\n// );\n\n// const deleteCar = createAsyncThunk<number, number, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/deleteCar',\n//    async (id, { rejectWithValue, getState }) => {\n//       const data = await fetchDeleteCar(id);\n//       const { winnersList } = getState().list;\n//       const carIsWinner = winnersList.some((winner) => winner.id === id);\n//       if (carIsWinner) fetchDeleteWinner(id);\n//       if (data.isFailed) return rejectWithValue({ isFailed: true });\n\n//       return data;\n//    }\n// );\n\n// const getGarageLists = createAsyncThunk<Car[], void, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/getGarageLists',\n//    async (props, { rejectWithValue }) => {\n//       const data = await fetchGarageList();\n//       if (data.isFailed) return rejectWithValue({ isFailed: true });\n\n//       return data;\n//    }\n// );\n\n// const getWinnersLists = createAsyncThunk<Winner[], void, { state: RootState; rejectValue: { isFailed: boolean } }>(\n//    'list/getWinnersLists',\n//    async (props, { rejectWithValue }) => {\n//       const data = await fetchWinnersList();\n//       if (data.isFailed) return rejectWithValue({ isFailed: true });\n\n//       return data;\n//    }\n// );\n\n// const initialState: ListState = {\n//    garageList: [],\n//    winnersList: [],\n//    selectedCar: undefined,\n//    loading: false,\n//    race: undefined,\n//    winner: undefined,\n//    winnerPopup: false,\n//    winnersSortBy: undefined,\n//    winnersSortDirection: undefined,\n// };\n\n// const appSlice = createSlice({\n//    name: 'list',\n//    initialState,\n//    reducers: {\n//       setSelectedCar(state, { payload }) {\n//          state.selectedCar = payload;\n//       },\n//       setRace(state, { payload }) {\n//          if (payload != 'finished') state.winner = undefined;\n//          state.race = payload;\n//       },\n//       closeWinnerPopup(state) {\n//          state.winnerPopup = false;\n//       },\n//       setWinnersList(state, { payload }) {\n//          state.winnersList = payload;\n//       },\n//    },\n//    extraReducers: (builder) => {\n//       builder\n//          .addCase(deleteCar.pending, (state, { meta }) => {\n//             const selectedId = state.selectedCar?.id;\n//             const deletingId = meta.arg;\n//             if (selectedId !== undefined && selectedId === deletingId) {\n//                state.selectedCar = undefined;\n//             }\n//          })\n//          .addCase(deleteCar.fulfilled, (state, { meta }) => {\n//             state.garageList = state.garageList.filter((car) => car.id !== meta.arg);\n//             state.winnersList = state.winnersList.filter((car) => car.id !== meta.arg);\n//          })\n//          .addCase(newWinner.pending, (state, { meta }) => {\n//             state.race = 'finished';\n//             state.winner = meta.arg;\n//             state.winnerPopup = true;\n//          })\n//          .addCase(newWinner.fulfilled, (state, { meta }) => {\n//             state.winnersList = [\n//                ...state.winnersList,\n//                {\n//                   name: meta.arg.name || 'name',\n//                   color: meta.arg.color || '#ccc',\n//                   id: meta.arg.id || 3,\n//                   time: meta.arg.time || 33,\n//                   wins: 1,\n//                },\n//             ];\n//          })\n//          .addCase(updateWinner.pending, (state) => {\n//             state.race = 'finished';\n//          })\n//          .addCase(updateWinner.fulfilled, (state, { meta }) => {\n//             state.winnersList = state.winnersList.map((winner) =>\n//                winner.id === meta.arg.id\n//                   ? {\n//                        ...winner,\n//                        wins: meta.arg.wins,\n//                        time: meta.arg.time,\n//                     }\n//                   : winner\n//             );\n//          })\n//          .addCase(addNewCar.fulfilled, (state, { meta }) => {\n//             state.garageList = [\n//                ...state.garageList,\n//                {\n//                   name: meta.arg.name,\n//                   color: meta.arg.color,\n//                   id: state.garageList.length ? state.garageList[state.garageList.length - 1].id + 1 : 1,\n//                },\n//             ];\n//          })\n//          .addCase(updateCar.fulfilled, (state, { meta }) => {\n//             state.garageList = state.garageList.map((car) =>\n//                car.id === meta.arg.id\n//                   ? {\n//                        color: meta.arg.color,\n//                        name: meta.arg.name,\n//                        id: meta.arg.id,\n//                     }\n//                   : car\n//             );\n//          })\n//          .addCase(getGarageLists.pending, (state) => {\n//             state.loading = true;\n//          })\n//          .addCase(getGarageLists.fulfilled, (state, { payload }) => {\n//             state.garageList = payload;\n//             state.loading = false;\n//          })\n//          .addCase(getGarageLists.rejected, (state, { payload }) => {\n//             state.loading = false;\n//          })\n//          .addCase(getWinnersLists.fulfilled, (state, { payload }) => {\n//             const restyleList: Winner[] = payload\n//                .map((winner: Partial<Winner>) => {\n//                   const car = state.garageList.find((current) => current.id === winner.id);\n//                   if (car?.name && car?.color && winner?.id && winner?.time && winner?.wins)\n//                      return {\n//                         ...winner,\n//                         name: car.name,\n//                         color: car.color,\n//                      };\n//                })\n//                .filter((winner): winner is Winner => winner !== undefined);\n//             state.winnersList = restyleList;\n//             state.loading = false;\n//          })\n//          .addCase(getWinnersLists.rejected, (state) => {\n//             state.loading = false;\n//          });\n//    },\n// });\n\n// export const { setRace, setSelectedCar, closeWinnerPopup, setWinnersList } = appSlice.actions;\n// export { getGarageLists, getWinnersLists, generateCars, addNewCar, updateCar, deleteCar, newWinner, updateWinner };\n// export default appSlice.reducer;\n\n/* eslint-disable */\n/* prettier-ignore */\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { fetchWinnersList, fetchNewWinner, fetchUpdateWinner, fetchDeleteWinner } from 'CONSTANTS/Axios';\nimport type { RootState } from 'store/configureReduxStore';\nimport { Car, openWinnerPopup, setRace } from './garageListReducer';\n\nexport interface Winner {\n   id: number;\n   wins: number;\n   time: number;\n   name: string;\n   color: string;\n}\n\ninterface WinnersState {\n   winnersList: Winner[];\n   winner?: Partial<Winner>;\n   loading: boolean;\n}\n\nconst initialState: WinnersState = {\n   winnersList: [],\n   winner: undefined,\n   loading: false,\n};\n\nconst newWinner = createAsyncThunk<Winner, Partial<Winner>, { state: RootState; rejectValue: { isFailed: boolean } }>(\n   'winnersList/newWinner',\n   async (carData, { rejectWithValue, dispatch }) => {\n      const data = await fetchNewWinner(carData);\n      if (data.isFailed) return rejectWithValue({ isFailed: true });\n      dispatch(setRace('finished'));\n      dispatch(openWinnerPopup());\n\n      return data;\n   }\n);\n\nconst updateWinner = createAsyncThunk<Winner, Winner, { state: RootState; rejectValue: { isFailed: boolean } }>(\n   'winnersList/updateWinner',\n   async (carData, { rejectWithValue }) => {\n    console.log('carData new winner: ', carData);\n      const data = await fetchUpdateWinner(carData);\n      if (data.isFailed) return rejectWithValue({ isFailed: true });\n\n      return data;\n   }\n);\n\nconst deleteWinner = createAsyncThunk<number, number, { state: RootState; rejectValue: { isFailed: boolean } }>(\n   'winnersList/deleteWinner',\n   async (id, { rejectWithValue }) => {\n      const data = await fetchDeleteWinner(id);\n      if (data.isFailed) return rejectWithValue({ isFailed: true });\n\n      return data;\n   }\n);\n\nconst getWinnersLists = createAsyncThunk<Winner[], void, { state: RootState; rejectValue: { isFailed: boolean } }>(\n   'winnersList/getWinnersLists',\n   async (props, { rejectWithValue, getState }) => {\n      const data = await fetchWinnersList();\n      if (data.isFailed) return rejectWithValue({ isFailed: true });\n      const { garageList } = getState().garageList;\n\n      return data.map((winner: Winner) => {\n         const car = garageList.find((car: Car) => car.id === winner.id);\n         return { ...winner, name: car?.name || 'unknown', color: car?.color || '#ccc' };\n      });\n   }\n);\n\nconst winnersListReducer = createSlice({\n   name: 'winnersList',\n   initialState,\n   reducers: {\n      setWinnersList(state, { payload }) {\n         state.winnersList = payload;\n      },\n   },\n   extraReducers: (builder) => {\n      builder\n         .addCase(newWinner.pending, (state, { meta }) => {\n            state.winner = meta.arg;\n         })\n         .addCase(newWinner.fulfilled, (state, { meta }) => {\n            state.winnersList.push({\n               id: meta.arg.id!,\n               time: meta.arg.time!,\n               wins: 1,\n               name: meta.arg.name || 'car',\n               color: meta.arg.color || '#ccc',\n            });\n         })\n         .addCase(updateWinner.fulfilled, (state, { meta }) => {\n            state.winnersList = state.winnersList.map((winner) =>\n               winner.id === meta.arg.id ? { ...winner, wins: meta.arg.wins, time: meta.arg.time } : winner\n            );\n         })\n         .addCase(deleteWinner.fulfilled, (state, { payload }) => {\n            state.winnersList = state.winnersList.filter((winner) => winner.id !== payload);\n         })\n         .addCase(getWinnersLists.pending, (state) => {\n            state.loading = true;\n         })\n         .addCase(getWinnersLists.fulfilled, (state, { payload }) => {\n            state.winnersList = payload;\n            state.loading = false;\n         })\n         .addCase(getWinnersLists.rejected, (state) => {\n            state.loading = false;\n         });\n   },\n});\n\nexport const { setWinnersList } = winnersListReducer.actions;\nexport { updateWinner, getWinnersLists, deleteWinner, newWinner };\nexport default winnersListReducer.reducer;\n"],"mappings":"AAAA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}